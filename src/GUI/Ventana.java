/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package GUI;

/**
 *
 * @author cbaidon45
 */

public class Ventana extends javax.swing.JFrame {

    /**
     * Creates new form Ventana
     */
    public Ventana() {
        initComponents();
        
    }
    int peso=0;

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextField1.setText("Stacy barbara ha hablado para recuperar su carta");
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        jLabel1.setText("Introduce una frase:");

        jButton1.setText("OK");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel2.setText("Respuesta:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 458, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(193, 193, 193)
                        .addComponent(jButton1)))
                .addContainerGap(239, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addGap(97, 97, 97)
                .addComponent(jButton1)
                .addContainerGap(235, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField1ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        String texto=jTextField1.getText();                 //recibo el texto del campo de texto
        String []palabras=ObtenerPalabras(texto);           //obtengo las palabras
        int []orden=EvaluarValores(EvaluarPalabras(palabras));  //Evaluo el orden en el que deben mostrarse
        String resultado="";
        int i=0;
        while(i<orden.length)
        {System.out.println(palabras[orden[i]]);;
        resultado=resultado+" "+palabras[orden[i]];
        i=i+1;
        }
        jLabel3.setText(resultado);
        
        
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Ventana.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Ventana.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Ventana.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Ventana.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Ventana().setVisible(true);
            }
        });
    }
    public int ContarPalabras(String texto){
        int i=0;                             //Inicializare una variable para recorrer toda la frase   
        int espacios=1;                     //Considerare que la frase no comienza con espacios, asi que el principio debera ser una palabra
        while(i<texto.length())             //Voy a recorrer toda la frase buscando palabras
        {
        String temporal=String.valueOf(texto.charAt(i));//Guardaremos el caracter en un campo temporal de tipo String
                                                        //De esta manera posteriormente podre realizar la comparacion con " "
        if(temporal.compareTo(" ")==0)                  //Si la comparacion es igual esto debe dar cero
        {espacios=espacios+1;}                          //entonces esto quiere decir que encontre un espacio
                                                        //que a su vez es un separador de palabras
        i=i+1;                                          //OK, ahora avanzare con el siguiente caracter
        }
        //System.out.println(espacios);                 //una pequeña prueba que me ayuda a evaluar como va mi codigo
        return espacios;                                //El numero de palabras se utilizara mas adelante
     }
    
        public String[] ObtenerPalabras(String texto){
        int i=0;  //Se inicializa una variable para que recorra toda la frase
        int j=0;  //Se inicializa una variable para que vaya guardando las palabras en el arreglo
        int espacios=1; //Normalmente las palabras se separan con espacios, considerare el inicio del texto con una palabra
        String acumulada=""; //Aqui se ira guardando el SubString acumulado para ir guardando la palabra
        String []palabras=new String[ContarPalabras(texto)]; //Usando este metodo, podemos inicializar este arreglo 
                                                            //con el numero exacto de palabras
        while(i<texto.length())                             //Voy a recorrer todo el texto
        {
        String temporal=String.valueOf(texto.charAt(i));    //Guardaremos el caracter en un campo temporal de tipo String
                                                            //De esta manera posteriormente podre realizar la comparacion con " "
        acumulada=acumulada+temporal;                       //Acumulare todos los caracteres
        if((temporal.compareTo(" ")==0)||(i==texto.length()-1)) //Siempre y cuando no encuentre un espacio o el final del texto
        {
        palabras[j]=acumulada;                              //Al encontrar un espacio o el final del texto, guardare esa palabra
                                                           //en el arreglo palabras
        //System.out.println(palabras[j]);    
        j=j+1;
        acumulada="";                                       //aqui vacio mi variable temporal para prepararla para la siguiente palabra 
        if (i==texto.length()-1)                            //Si llego al final del texto me saldre de este bucle
                                                            //para prevenir cualquier detalle
            break;
        }
        i=i+1;                                              //Mientras no me salga de este bucle, en esta parte ire avanzando i
                                                            //para recorrer todo el texto
        }
        return palabras;
        
     }
        public int LetraA(String texto){
        int i=0;                                        //inicializo una variable para recorrer la palabra
        int j=0;                                        //inicializo esta variable para recorrer el arreglo de palabras
        int valor=0;                                    //este es el valor de las palabras ira cambiando conforme encontremos valores
        while(i<texto.length())                         //comienzo a recorrer la palabra    
        {
        String temporal=String.valueOf(texto.charAt(i));    //Convierto el caracter a String para poder realizar la comparacion
        if((temporal.compareTo("a")==0)||(temporal.compareTo("A")==0))  //Considere tanto a minuscula como mayuscula
        {                                                   //peso lo considere variable global, para que aunque salga de algun metodo
                                                            //siga incrementandose como debe de ser
        peso=peso+1;                                        //cada que encuentro una a el peso incrementa en 1
        valor=valor+peso;                                   //y esa palabra ira aumentando su valor
        //    System.out.println(valor);
        }
        i=i+1;                                              //OK, ahora voy a evaluar el siguiente caracter
        if (i==texto.length())                              //si llego a la longitud del texto, rompo el bucle                                              
        break;
        }                                                    
        return valor;                                       //el valor que obtuve para esa palabra lo mando al siguiente metodo
        }
        
        public int[] EvaluarPalabras(String palabras[]){            //con este metodo evaluo todas las palabras
        //String []palabras=new String[ContarPalabras(texto)];
        int[] ValorPalabra=new int[palabras.length];                //armo el arreglo de la longitud equivalente al numero de palabras    
        int i=0;                                                    //inicializo una variable para recorrer el arreglo de palabras
        while(i<palabras.length){                                   
        ValorPalabra[i]=LetraA(palabras[i]);                        //me apoyo en un metodo que cree mas arriba, para simplificar todo
            //System.out.println("Palabra:"+palabras[i]);           y luego guardo todo en un arreglo, donde coloco los valores de cada palabra
            //System.out.println("Valor:"+ValorPalabra[i]);         estos println, los use para efectos de prueba durante la programacion
        i++;                                                        //OK, ahora vamos a evaluar la siguiente palabra
        }
        return ValorPalabra;                                        //al final tendre un arreglo con los valores de todas las palabras
        
        }
        
        public int[] EvaluarValores(int palabras[]){                //La idea aqui es ordenar de mayor a menor y guardar las pocisiones
        int[] espejo=new int[palabras.length];                      //un arreglo espejo, un pequeño truco que se me ocurrio
        int[] ordenado=new int[palabras.length];                    // en este arreglo ire guardando todos los resultados de este ordenamiento
        int i=0;                                                    //para recorrer el arreglo en el primer ciclo anidado
        int j=0;                                                    //para recorrer el arreglo en el segundo ciclo anidado
        int k=0;                                                    //para guardar la posicion, opte por separarlo
                                                                    //para evitar confusiones y complicaciones
        while(i<palabras.length){                                   //voy a recorrer el primer arreglo
        espejo[i]=palabras[i];                                      // y copiarlo al arreglo espejo
                                                                    //esto con la precaucion de que si algo sale mal o requiero
                                                                    //evaluar algo, tendre el arreglo original intacto
        i++;                                                    //avanzo en el arreglo
        }
        i=0;                                                    //inicializo nuevamente mi variable para otro ciclo
        int max=-2;                                             //colocare el maximo en -2, ya que usare el -1 para descartar
                                                                //las pocisiones en las que ya encontre un maximo 
        int pocision=0;                                         //inicializare la pocision en 0
        
        while(j<palabras.length){                               //este es el segundo arreglo anidado
        while(i<palabras.length){                               //este es el primer arreglo anidado
        if(espejo[i]>max)                                       //aqui voy a buscar el maximo del arreglo
        {max=espejo[i];                                         //uso la variable max para ir rastreando el maximo
        pocision=i;                                             //y guardare la pocision que es lo que quiero obtener
        }
        i=i+1;                                                  //sigo recorriendo el arreglo
        }
        espejo[pocision]=-1;                                    //una vez que recorri todo el arreglo, descarto este valor dejandolo 
                                                                //-1, el valor minimo posible para una palabra para este caso es cero
                                                                // en caso de que no tenga la letra a, asi que con -1, podre descartar
                                                                //esta pocision y continuar evaluando el resto del arreglo
        ordenado[k]=pocision;                                   //guardo la posicion en un arreglo
       // System.out.println(ordenado[k]);
        i=0;                                                    //inicializo mi variable para otra vuelta en el ciclo    
        j=j+1;                                                  //continuare recorriendo este ciclo
        k=k+1;                                                  //recorro la pocision para el proximo maximo que encuentre
        max=-2;                                                 //para evitar comparaciones iguales, pongo este valor en -2
        pocision=0;                                             //re inicializo en 0, para evitar quedarme con algun valor anterior
            
        }
        return ordenado;                                        //al final entrego el arreglo al siguiente metodo
        
}
        
        

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
}
